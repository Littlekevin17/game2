<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puissance 4</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Définition des variables CSS pour un thème de couleur cohérent */
        :root {
            --bg-color: #f0f4f8;
            --primary-color: #4f46e5;
            --secondary-color: #8b5cf6;
            --player1-color: #ef4444; /* Rouge */
            --player2-color: #facc15; /* Jaune */
            --board-bg-color: #3b82f6;
            --card-bg-color: #ffffff;
            --text-color: #1f2937;
            --shadow-color: rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            flex-direction: column;
            position: relative; /* Pour positionner l'écran de démarrage */
        }

        .game-container {
            width: 100%;
            max-width: 600px;
            background-color: var(--card-bg-color);
            border-radius: 20px;
            box-shadow: 0 10px 25px var(--shadow-color);
            padding: 30px;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .status-container {
            min-height: 30px;
            margin: 20px 0;
        }

        #message {
            font-size: 1.25rem;
            font-weight: 700;
        }

        canvas {
            display: block;
            margin: 0 auto;
            background-color: var(--board-bg-color);
            border-radius: 10px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.2);
            touch-action: none;
        }
        
        .controls {
            margin-top: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .controls-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button, select {
            background-color: var(--secondary-color);
            color: var(--card-bg-color);
            font-family: 'Inter', sans-serif;
            font-weight: 700;
            border: none;
            padding: 12px 24px;
            font-size: 1rem;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(139, 92, 246, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button.active {
            background-color: var(--primary-color);
            box-shadow: 0 5px 15px rgba(79, 70, 229, 0.4);
        }

        button:hover, select:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(139, 92, 246, 0.5);
        }

        button:active, select:active {
            transform: translateY(0);
            box-shadow: 0 5px 15px rgba(139, 92, 246, 0.4);
        }
        
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            text-align: center;
        }

        /* Styles pour les messages de statut spécifiques */
        .player1-turn {
            color: var(--player1-color);
        }

        .player2-turn {
            color: var(--player2-color);
        }

        .win-message {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Styles pour l'écran de démarrage */
        .start-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
        }

        .start-menu.hidden {
            opacity: 0;
            pointer-events: none; /* Empêche les clics lorsque masqué */
        }

        .start-menu-content {
            background-color: var(--card-bg-color);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 90%;
            max-width: 400px;
        }

        .start-menu-content h2 {
            margin-top: 0;
            font-size: 1.5rem;
            color: var(--primary-color);
        }

        /* Règle CSS pour les petits écrans afin de maximiser l'espace */
        @media (max-width: 650px) {
            body {
                padding: 10px;
            }
            .game-container {
                padding: 20px;
            }
            .start-menu-content {
                padding: 30px;
            }
        }
    </style>
</head>
<body>

<div class="game-container">
    <div class="status-container">
        <p id="message">C'est au tour du joueur 1 !</p>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div class="controls">
        <button id="resetButton" style="display: none;">Recommencer la partie</button>
    </div>
</div>

<!-- Nouvel écran de démarrage -->
<div id="startMenu" class="start-menu">
    <div class="start-menu-content">
        <h2>Choisissez votre mode de jeu</h2>
        <div class="controls-row">
            <button id="modeTwoPlayersButton" class="active">2 Joueurs</button>
            <button id="modeAIButton">Contre l'IA</button>
        </div>
        <div class="controls-row" id="difficultyControls" style="display: none;">
            <label for="difficultySelect" style="font-weight: 700;">Difficulté :</label>
            <select id="difficultySelect">
                <option value="easy">Facile</option>
                <option value="medium">Moyen</option>
                <option value="hard">Difficile</option>
            </select>
        </div>
        <button id="startButton">Commencer la partie</button>
    </div>
</div>

<script>
    // Variables de configuration du jeu
    const rows = 6;
    const cols = 7;
    const padding = 10;
    let cell_size;
    let board;
    let currentPlayer;
    let game_over;
    let gameMode = 'twoPlayers'; // 'twoPlayers' ou 'vsAI'
    let aiDifficulty = 'easy'; // 'easy', 'medium', 'hard'
    let isAITurn = false;
    
    // Variables pour l'algorithme Minimax (ajustées)
    const MAX_DEPTH = 5; // Augmentation de la profondeur d'anticipation pour l'IA difficile

    // Récupération des éléments du DOM
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const messageElement = document.getElementById('message');
    const resetButton = document.getElementById('resetButton');

    // Éléments de l'écran de démarrage
    const startMenu = document.getElementById('startMenu');
    const startButton = document.getElementById('startButton');
    const modeTwoPlayersButton = document.getElementById('modeTwoPlayersButton');
    const modeAIButton = document.getElementById('modeAIButton');
    const difficultyControls = document.getElementById('difficultyControls');
    const difficultySelect = document.getElementById('difficultySelect');

    // Mettre en place le canevas et commencer le jeu
    window.addEventListener('load', () => {
        // Initialiser le jeu et le plateau dès le chargement de la page
        setupGame();
        // Puis afficher le menu de démarrage
        showStartMenu();
    });
    window.addEventListener('resize', setupCanvas);
    window.addEventListener('orientationchange', setupCanvas);
    canvas.addEventListener('click', handleUserClick);
    resetButton.addEventListener('click', showStartMenu);
    startButton.addEventListener('click', startGame);
    modeTwoPlayersButton.addEventListener('click', () => setGameMode('twoPlayers'));
    modeAIButton.addEventListener('click', () => setGameMode('vsAI'));
    difficultySelect.addEventListener('change', (e) => aiDifficulty = e.target.value);

    // Empêche le défilement de l'écran sur les appareils tactiles
    canvas.addEventListener('touchmove', (event) => {
        event.preventDefault();
    }, { passive: false });

    /**
     * @description Affiche l'écran de démarrage pour choisir le mode de jeu.
     */
    function showStartMenu() {
        startMenu.classList.remove('hidden');
        resetButton.style.display = 'none'; // Masquer le bouton de réinitialisation
        // S'assurer que le canevas est redimensionné correctement
        setupCanvas();
    }

    /**
     * @description Démarre la partie en cachant l'écran de démarrage.
     */
    function startGame() {
        startMenu.classList.add('hidden');
        resetButton.style.display = 'block'; // Afficher le bouton de réinitialisation
        setupGame();
    }

    /**
     * @description Définit le mode de jeu (2 joueurs ou contre l'IA).
     * @param {string} mode Le mode de jeu à définir ('twoPlayers' ou 'vsAI').
     */
    function setGameMode(mode) {
        gameMode = mode;
        if (mode === 'vsAI') {
            modeTwoPlayersButton.classList.remove('active');
            modeAIButton.classList.add('active');
            difficultyControls.style.display = 'flex';
        } else {
            modeTwoPlayersButton.classList.add('active');
            modeAIButton.classList.remove('active');
            difficultyControls.style.display = 'none';
        }
    }

    /**
     * @description Initialise ou réinitialise l'état du jeu.
     */
    function setupGame() {
        board = createBoard();
        currentPlayer = 1;
        game_over = false;
        isAITurn = false;
        
        messageElement.textContent = "C'est au tour du joueur 1 !";
        messageElement.className = 'player1-turn';
        drawBoard();
    }

    /**
     * @description Calcule et ajuste la taille du canevas pour qu'il s'adapte à l'écran.
     */
    function setupCanvas() {
        // Le canevas est redimensionné pour s'adapter à la largeur de son conteneur parent.
        const containerWidth = canvas.parentElement.clientWidth;
        const availableWidth = containerWidth - (30 * 2); // 30px de padding à gauche et à droite
        
        // La taille de la cellule est calculée pour que la grille tienne dans l'espace disponible
        const cell_size_by_width = Math.floor((availableWidth - (cols - 1) * padding) / cols);
        cell_size = cell_size_by_width;

        if (cell_size <= 0) {
            cell_size = 30; // Valeur de repli au cas où le calcul serait négatif ou nul
        }
        
        // Mise à jour de la largeur et de la hauteur du canevas
        canvas.width = cols * cell_size + (cols + 1) * padding;
        canvas.height = rows * cell_size + (rows + 1) * padding;

        drawBoard();
    }

    /**
     * @description Crée un tableau 2D pour représenter le plateau de jeu.
     * @returns {Array<Array<number>>} Le tableau de jeu rempli de zéros.
     */
    function createBoard() {
        return Array.from({ length: rows }, () => Array(cols).fill(0));
    }

    /**
     * @description Dessine le plateau de jeu et tous les jetons placés sur le canevas.
     */
    function drawBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Dessiner le fond du plateau
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board-bg-color');
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                drawCell(row, col);
            }
        }
    }

    /**
     * @description Dessine une seule cellule (un trou) sur le plateau.
     * @param {number} row La ligne de la cellule.
     * @param {number} col La colonne de la cellule.
     */
    function drawCell(row, col) {
        const x = col * (cell_size + padding) + padding + cell_size / 2;
        const y = row * (cell_size + padding) + padding + cell_size / 2;
        const radius = cell_size / 2;

        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        
        // Dessiner le jeton si la cellule est occupée
        if (board[row][col] === 1) {
            drawPiece(x, y, radius, getComputedStyle(document.documentElement).getPropertyValue('--player1-color'));
        } else if (board[row][col] === 2) {
            drawPiece(x, y, radius, getComputedStyle(document.documentElement).getPropertyValue('--player2-color'));
        } else {
            // Dessiner un trou vide
            ctx.fillStyle = 'white';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetY = 3;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
        }
        ctx.closePath();
    }

    /**
     * @description Dessine un jeton avec un effet 3D.
     * @param {number} x La position en X du jeton.
     * @param {number} y La position en Y du jeton.
     * @param {number} radius Le rayon du jeton.
     * @param {string} color La couleur du jeton.
     */
    function drawPiece(x, y, radius, color) {
        // Effet de gradient pour un aspect 3D
        const gradient = ctx.createRadialGradient(x + radius * 0.3, y - radius * 0.3, radius * 0.1, x, y, radius);
        gradient.addColorStop(0, 'white');
        gradient.addColorStop(0.5, color);
        gradient.addColorStop(1, '#666');
        
        ctx.fillStyle = gradient;
        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
        ctx.shadowBlur = 8;
        ctx.shadowOffsetY = 4;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.shadowOffsetY = 0;
    }

    /**
     * @description Gère le clic de l'utilisateur sur le canevas.
     * @param {MouseEvent} event L'objet événement de la souris.
     */
    function handleUserClick(event) {
        if (game_over || (gameMode === 'vsAI' && isAITurn)) return;

        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        
        // Déterminer la colonne cliquée
        const col = Math.floor(mouseX / (cell_size + padding));
        
        if (col >= 0 && col < cols) {
            if (dropPiece(col)) { // Si la pièce a été placée avec succès
                if (gameMode === 'vsAI' && !game_over) {
                    isAITurn = true;
                    switchPlayer(); // Change le joueur en 2 (l'IA)
                    messageElement.textContent = `L'IA réfléchit...`;
                    messageElement.className = 'player2-turn';
                    setTimeout(makeAIMove, 1000); // L'IA joue après un petit délai
                }
            }
        }
    }

    /**
     * @description Place un jeton dans une colonne spécifiée.
     * @param {number} col La colonne où placer le jeton.
     * @returns {boolean} Vrai si le jeton a été placé, faux si la colonne est pleine.
     */
    function dropPiece(col) {
        for (let row = rows - 1; row >= 0; row--) {
            if (board[row][col] === 0) {
                board[row][col] = currentPlayer;
                drawBoard();

                if (checkWin(row, col)) {
                    messageElement.textContent = `Le joueur ${currentPlayer} a gagné !`;
                    messageElement.className = `player${currentPlayer}-turn win-message`;
                    game_over = true;
                } else if (checkDraw()) {
                    messageElement.textContent = "Match nul !";
                    messageElement.className = '';
                    game_over = true;
                } else {
                    if (gameMode === 'twoPlayers') {
                        switchPlayer();
                    }
                }
                return true;
            }
        }
        return false;
    }
    
    /**
     * @description L'IA joue son tour en fonction de la difficulté sélectionnée.
     */
    function makeAIMove() {
        if (game_over) return;
        
        let bestCol;
        switch (aiDifficulty) {
            case 'easy':
                bestCol = chooseRandomMove();
                break;
            case 'medium':
                // Pour le mode "moyen", l'IA se concentre sur les coups de victoire et de blocage immédiat
                let winningMove = findWinningMove(2);
                if (winningMove !== null) {
                    bestCol = winningMove;
                } else {
                    let blockingMove = findWinningMove(1);
                    if (blockingMove !== null) {
                        bestCol = blockingMove;
                    } else {
                        bestCol = chooseRandomMove();
                    }
                }
                break;
            case 'hard':
                // Pour le mode "difficile", l'IA utilise l'algorithme Minimax pour anticiper
                bestCol = minimax(board, MAX_DEPTH, -Infinity, Infinity, true).column;
                break;
        }

        if (bestCol !== null) {
            dropPiece(bestCol);
        }
        
        if (!game_over) {
            isAITurn = false;
            switchPlayer(); // Passe le tour au joueur 1 (humain)
        }
    }
    
    /**
     * @description L'IA choisit une colonne aléatoire.
     * @returns {number | null} La colonne choisie ou null si aucune colonne n'est disponible.
     */
    function chooseRandomMove() {
        const validCols = [];
        for (let c = 0; c < cols; c++) {
            if (board[0][c] === 0) {
                validCols.push(c);
            }
        }
        if (validCols.length > 0) {
            const randomIndex = Math.floor(Math.random() * validCols.length);
            return validCols[randomIndex];
        }
        return null;
    }
    
    /**
     * @description Trouve un coup gagnant pour un joueur donné.
     * @param {number} player Le joueur à vérifier (1 ou 2).
     * @returns {number | null} La colonne gagnante ou null si aucune n'est trouvée.
     */
    function findWinningMove(player) {
        for (let c = 0; c < cols; c++) {
            for (let r = rows - 1; r >= 0; r--) {
                if (board[r][c] === 0) {
                    board[r][c] = player;
                    if (checkWin(r, c)) {
                        board[r][c] = 0; // Annuler le coup simulé
                        return c;
                    }
                    board[r][c] = 0; // Annuler le coup simulé
                    break;
                }
            }
        }
        return null;
    }
    
    /**
     * @description Implémente l'algorithme Minimax pour le mode difficile.
     * @param {Array<Array<number>>} nodeBoard Le tableau de jeu actuel.
     * @param {number} depth La profondeur de recherche restante.
     * @param {number} alpha Meilleur score pour le joueur maximisant.
     * @param {number} beta Meilleur score pour le joueur minimisant.
     * @param {boolean} isMaximizingPlayer Vrai si c'est le tour de l'IA (maximisation), faux sinon.
     * @returns {{column: number, score: number}} Le meilleur coup et son score.
     */
    function minimax(nodeBoard, depth, alpha, beta, isMaximizingPlayer) {
        const validCols = getValidColumns(nodeBoard);
        const score = scoreBoard(nodeBoard);

        // Conditions d'arrêt de la récursion
        if (depth === 0 || gameIsOver(nodeBoard)) {
            return { column: null, score: score };
        }
        
        // Si le plateau est évalué comme gagnant ou perdant, on retourne les scores instantanés.
        if (score >= 100000) return { column: null, score: score };
        if (score <= -100000) return { column: null, score: score };

        if (isMaximizingPlayer) { // C'est le tour de l'IA (joueur 2)
            let bestScore = -Infinity;
            let bestColumn = validCols[0];
            
            for (const col of validCols) {
                const tempBoard = dropPieceOnBoard(nodeBoard, col, 2);
                
                const evaluation = minimax(tempBoard, depth - 1, alpha, beta, false);
                if (evaluation.score > bestScore) {
                    bestScore = evaluation.score;
                    bestColumn = col;
                }
                alpha = Math.max(alpha, bestScore);
                if (alpha >= beta) {
                    break; // Élagage Alpha-Beta
                }
            }
            return { column: bestColumn, score: bestScore };
        } else { // C'est le tour de l'humain (joueur 1)
            let bestScore = Infinity;
            let bestColumn = validCols[0];
            
            for (const col of validCols) {
                const tempBoard = dropPieceOnBoard(nodeBoard, col, 1);
                
                const evaluation = minimax(tempBoard, depth - 1, alpha, beta, true);
                if (evaluation.score < bestScore) {
                    bestScore = evaluation.score;
                    bestColumn = col;
                }
                beta = Math.min(beta, bestScore);
                if (alpha >= beta) {
                    break; // Élagage Alpha-Beta
                }
            }
            return { column: bestColumn, score: bestScore };
        }
    }

    /**
     * @description Évalue un plateau de jeu pour l'IA.
     * @param {Array<Array<number>>} boardToScore Le tableau de jeu à évaluer.
     * @returns {number} Le score d'évaluation.
     */
    function scoreBoard(boardToScore) {
        let score = 0;

        // Score basé sur le centre du plateau, car c'est une position stratégique
        const centerCol = Math.floor(cols / 2);
        for (let r = 0; r < rows; r++) {
            if (boardToScore[r][centerCol] === 2) score += 3;
        }

        // Score basé sur les fenêtres de 4 jetons
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                // Vérifier les fenêtres horizontales
                if (c <= cols - 4) {
                    const window = boardToScore[r].slice(c, c + 4);
                    score += evaluateWindow(window);
                }
                // Vérifier les fenêtres verticales
                if (r <= rows - 4) {
                    const window = [boardToScore[r][c], boardToScore[r + 1][c], boardToScore[r + 2][c], boardToScore[r + 3][c]];
                    score += evaluateWindow(window);
                }
                // Vérifier les fenêtres diagonales (montantes)
                if (c <= cols - 4 && r <= rows - 4) {
                    const window = [boardToScore[r][c], boardToScore[r + 1][c + 1], boardToScore[r + 2][c + 2], boardToScore[r + 3][c + 3]];
                    score += evaluateWindow(window);
                }
                // Vérifier les fenêtres diagonales (descendantes)
                if (c >= 3 && r <= rows - 4) {
                    const window = [boardToScore[r][c], boardToScore[r + 1][c - 1], boardToScore[r + 2][c - 2], boardToScore[r + 3][c - 3]];
                    score += evaluateWindow(window);
                }
            }
        }

        return score;
    }
    
    /**
     * @description Évalue une fenêtre de 4 jetons avec des scores plus agressifs.
     * @param {Array<number>} window La fenêtre de 4 jetons.
     * @returns {number} Le score de la fenêtre.
     */
    function evaluateWindow(window) {
        let score = 0;
        const player1Count = window.filter(piece => piece === 1).length;
        const player2Count = window.filter(piece => piece === 2).length;
        const emptyCount = window.filter(piece => piece === 0).length;

        // Si l'IA a une ligne de 4, c'est une victoire
        if (player2Count === 4) {
            score += 100000;
        } 
        // Si l'IA a une ligne de 3 avec une case vide, c'est une menace très forte
        else if (player2Count === 3 && emptyCount === 1) {
            score += 5000;
        } 
        // Si l'IA a une ligne de 2 avec deux cases vides
        else if (player2Count === 2 && emptyCount === 2) {
            score += 500;
        }

        // Si l'adversaire a une ligne de 4, c'est une défaite imminente
        if (player1Count === 4) {
            score -= 100000;
        } 
        // Si l'adversaire a une ligne de 3 avec une case vide, c'est une menace à bloquer
        else if (player1Count === 3 && emptyCount === 1) {
            score -= 5000;
        } 
        // Si l'adversaire a une ligne de 2 avec deux cases vides
        else if (player1Count === 2 && emptyCount === 2) {
            score -= 500;
        }

        return score;
    }

    /**
     * @description Vérifie si le jeu est terminé (victoire ou match nul).
     * @param {Array<Array<number>>} boardToTest Le tableau de jeu.
     * @returns {boolean} Vrai si le jeu est terminé, sinon Faux.
     */
    function gameIsOver(boardToTest) {
        // Vérifie les victoires de l'IA et du joueur
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if (boardToTest[r][c] !== 0) {
                    if (checkWinOnTempBoard(boardToTest, r, c, boardToTest[r][c])) {
                        return true;
                    }
                }
            }
        }
        // Vérifie si le plateau est plein
        return boardToTest[0].every(cell => cell !== 0);
    }
    
    /**
     * @description Obtient les colonnes valides pour un coup.
     * @param {Array<Array<number>>} boardToTest Le tableau de jeu.
     * @returns {Array<number>} Les indices des colonnes valides.
     */
    function getValidColumns(boardToTest) {
        const validCols = [];
        for (let c = 0; c < cols; c++) {
            if (boardToTest[0][c] === 0) {
                validCols.push(c);
            }
        }
        return validCols;
    }

    /**
     * @description Obtient la première ligne vide dans une colonne.
     * @param {Array<Array<number>>} boardToTest Le tableau de jeu.
     * @param {number} col La colonne.
     * @returns {number} L'indice de la ligne vide.
     */
    function getNextEmptyRow(boardToTest, col) {
        for (let r = rows - 1; r >= 0; r--) {
            if (boardToTest[r][col] === 0) {
                return r;
            }
        }
        return -1;
    }
    
    /**
     * @description Simule le placement d'une pièce sur un plateau temporaire.
     * @param {Array<Array<number>>} boardToTest Le tableau de jeu.
     * @param {number} col La colonne où placer le jeton.
     * @param {number} player Le joueur.
     * @returns {Array<Array<number>>} Une nouvelle copie du plateau avec la pièce placée.
     */
    function dropPieceOnBoard(boardToTest, col, player) {
        const newBoard = JSON.parse(JSON.stringify(boardToTest));
        for (let r = rows - 1; r >= 0; r--) {
            if (newBoard[r][col] === 0) {
                newBoard[r][col] = player;
                return newBoard;
            }
        }
        return newBoard;
    }
    
    /**
     * @description Vérifie si la partie est un match nul (le plateau est plein).
     * @returns {boolean} Vrai si le jeu est un match nul, sinon Faux.
     */
    function checkDraw() {
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if (board[r][c] === 0) {
                    return false; // Il y a encore des cellules vides
                }
            }
        }
        return true; // Le plateau est plein
    }

    /**
     * @description Bascule entre les joueurs 1 et 2.
     */
    function switchPlayer() {
        currentPlayer = currentPlayer === 1 ? 2 : 1;
        messageElement.textContent = `C'est au tour du joueur ${currentPlayer} !`;
        messageElement.className = `player${currentPlayer}-turn`;
    }

    /**
     * @description Vérifie si le joueur actuel a gagné à partir de la dernière pièce placée.
     * @param {number} row La ligne de la dernière pièce.
     * @param {number} col La colonne de la dernière pièce.
     * @returns {boolean} Vrai si le joueur a gagné, sinon Faux.
     */
    function checkWin(row, col) {
        return checkWinOnTempBoard(board, row, col, currentPlayer);
    }

    /**
     * @description Vérifie si le joueur a gagné sur un plateau donné.
     * @param {Array<Array<number>>} boardToTest Le tableau de jeu à vérifier.
     * @param {number} row La ligne de la dernière pièce.
     * @param {number} col La colonne de la dernière pièce.
     * @param {number} player Le joueur à vérifier.
     * @returns {boolean} Vrai si le joueur a gagné, sinon Faux.
     */
    function checkWinOnTempBoard(boardToTest, row, col, player) {
        // Directions à vérifier : horizontal, vertical, diagonal / et \
        const directions = [
            [0, 1],   // Horizontal
            [1, 0],   // Vertical
            [1, 1],   // Diagonal
            [1, -1]   // Anti-diagonal
        ];

        for (const [dr, dc] of directions) {
            let count = 1;
            // Vérifier dans une direction
            count += countLineOnTempBoard(boardToTest, row, col, dr, dc, player);
            // Vérifier dans la direction opposée
            count += countLineOnTempBoard(boardToTest, row, col, -dr, -dc, player);

            if (count >= 4) {
                return true;
            }
        }
        return false;
    }

    /**
     * @description Compte le nombre de jetons consécutifs dans une direction donnée sur un plateau temporaire.
     * @param {Array<Array<number>>} boardToTest Le tableau de jeu à vérifier.
     * @param {number} startRow La ligne de départ.
     * @param {number} startCol La colonne de départ.
     * @param {number} dr Le changement de ligne (par exemple, 1 pour aller vers le bas).
     * @param {number} dc Le changement de colonne (par exemple, 1 pour aller vers la droite).
     * @param {number} player Le joueur à vérifier.
     * @returns {number} Le nombre de jetons consécutifs.
     */
    function countLineOnTempBoard(boardToTest, startRow, startCol, dr, dc, player) {
        let count = 0;
        let r = startRow + dr;
        let c = startCol + dc;

        while (r >= 0 && r < rows && c >= 0 && c < cols && boardToTest[r][c] === player) {
            count++;
            r += dr;
            c += dc;
        }
        return count;
    }
</script>

</body>
</html>
