<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu de Snake</title>
    <!-- Chargement de la bibliothèque Phaser 3 via un CDN -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        /* Styles pour la page et le conteneur principal */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2c3e50;
            font-family: 'Arial', sans-serif;
            color: #ecf0f1;
        }

        #game-wrapper {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100vh;
            /* Limiter la taille du jeu sur les grands écrans */
            max-width: 800px;
            max-height: 800px;
            margin: auto;
        }

        /* Styles pour l'affichage du score */
        #score-display {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px #000;
        }

        /* Styles pour le conteneur du jeu Phaser */
        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            margin: 0 auto;
            border: 5px solid #34495e;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 10px;
        }

        /* Styles pour le bouton de plein écran */
        #fullscreen-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
        }

        #fullscreen-button:hover {
            background-color: #2980b9;
        }
        
        /* Styles pour les boutons tactiles */
        .touch-controls {
            display: none;
            margin-top: 20px;
            display: grid;
            grid-template-areas:
                ". up ."
                "left down right";
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 10px;
            justify-items: center;
            align-items: center;
            width: 200px;
        }

        .touch-controls.active {
            display: grid;
        }

        .touch-controls .button {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            color: white;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .touch-controls .button:active {
            background-color: rgba(255, 255, 255, 0.4);
        }

        .up-button { grid-area: up; }
        .left-button { grid-area: left; }
        .down-button { grid-area: down; }
        .right-button { grid-area: right; }

        @media (min-width: 768px) {
            .touch-controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <!-- Affichage du score en dehors du plateau de jeu -->
        <div id="score-display">Score: 0</div>
        <!-- Conteneur pour le jeu Phaser -->
        <div id="game-container"></div>
        <!-- Contrôles tactiles pour mobile -->
        <div id="touch-controls" class="touch-controls">
            <div class="button up-button" data-direction="up">▲</div>
            <div class="button left-button" data-direction="left">◀</div>
            <div class="button down-button" data-direction="down">▼</div>
            <div class="button right-button" data-direction="right">▶</div>
        </div>
        <!-- Bouton de plein écran -->
        <button id="fullscreen-button" style="display: none;">Plein écran</button>
    </div>

    <script>
        // game.js
        
        // --- Dimensions du jeu basées sur la fenêtre ---
        const ASPECT_RATIO = 25 / 20; // 5:4
        let GAME_WIDTH, GAME_HEIGHT;

        function updateGameDimensions() {
            const wrapper = document.getElementById('game-wrapper');
            const width = wrapper.clientWidth;
            const height = wrapper.clientHeight;
            
            // Calcul des dimensions du jeu en fonction de la taille de l'écran
            if (width / height > ASPECT_RATIO) {
                GAME_HEIGHT = height - 150; // Laisser de la place pour le score et les contrôles
                GAME_WIDTH = GAME_HEIGHT * ASPECT_RATIO;
            } else {
                GAME_WIDTH = width - 40;
                GAME_HEIGHT = GAME_WIDTH / ASPECT_RATIO;
            }

            // Assurer que les dimensions sont des multiples de la taille de la grille
            const GRID_SIZE = 20;
            GAME_WIDTH = Math.floor(GAME_WIDTH / GRID_SIZE) * GRID_SIZE;
            GAME_HEIGHT = Math.floor(GAME_HEIGHT / GRID_SIZE) * GRID_SIZE;
            
            if (GAME_WIDTH < GRID_SIZE * 3 || GAME_HEIGHT < GRID_SIZE * 3) {
                GAME_WIDTH = GRID_SIZE * 20;
                GAME_HEIGHT = GRID_SIZE * 20;
            }
        }

        updateGameDimensions();
        window.addEventListener('resize', () => {
            updateGameDimensions();
            if (game && game.isBooted) {
                game.scale.resize(GAME_WIDTH, GAME_HEIGHT);
            }
        });

        // Définition de la taille de la grille du jeu
        const GRID_SIZE = 20;

        // Configuration de Phaser
        const config = {
            type: Phaser.AUTO,
            width: GAME_WIDTH,
            height: GAME_HEIGHT,
            parent: 'game-container',
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            backgroundColor: '#3f68a7'
        };

        const game = new Phaser.Game(config);

        let snake;
        let food;
        let cursors;
        let score = 0;
        let gameOver = false;
        let direction = new Phaser.Math.Vector2(0, 0);
        let lastDirection = new Phaser.Math.Vector2(0, 0);
        let timeSinceLastMove = 0;
        const MOVE_INTERVAL = 150;

        const scoreDisplay = document.getElementById('score-display');
        const touchControls = document.getElementById('touch-controls');
        const gameWrapper = document.getElementById('game-wrapper');
        const fullscreenButton = document.getElementById('fullscreen-button');

        function preload() {}

        function create() {
            gameOver = false;
            score = 0;
            timeSinceLastMove = 0;
            direction.set(0, 0);
            lastDirection.set(0, 0);
            scoreDisplay.textContent = 'Score: 0';
            touchControls.classList.remove('active');

            // Afficher le bouton de plein écran si la fonctionnalité est supportée
            if (document.fullscreenEnabled) {
                fullscreenButton.style.display = 'block';
            }

            snake = [];
            const GAME_WIDTH_IN_BLOCKS = GAME_WIDTH / GRID_SIZE;
            const GAME_HEIGHT_IN_BLOCKS = GAME_HEIGHT / GRID_SIZE;
            for (let i = 0; i < 3; i++) {
                const segment = this.add.circle(
                    (GAME_WIDTH_IN_BLOCKS / 2 * GRID_SIZE) - (i * GRID_SIZE),
                    GAME_HEIGHT_IN_BLOCKS / 2 * GRID_SIZE,
                    GRID_SIZE / 2,
                    0x6aa84f
                ).setOrigin(0);
                snake.push(segment);
            }
            const head = snake[0];
            head.setFillStyle(0x76c46a);
            const eyeSize = GRID_SIZE / 8;
            const eye1 = this.add.circle(-eyeSize, -eyeSize, eyeSize, 0x000000);
            const eye2 = this.add.circle(eyeSize, -eyeSize, eyeSize, 0x000000);
            head.eyes = this.add.container(head.x + GRID_SIZE / 2, head.y + GRID_SIZE / 2, [eye1, eye2]);

            food = this.add.graphics();
            placeFood(this);

            this.tweens.add({
                targets: food,
                scale: 1.1,
                duration: 500,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            cursors = this.input.keyboard.createCursorKeys();

            const startText = this.add.text(
                GAME_WIDTH / 2,
                GAME_HEIGHT / 2,
                'Appuyez sur une flèche ou balayez pour commencer',
                {
                    fontSize: '24px',
                    fill: '#ecf0f1',
                    align: 'center',
                    wordWrap: { width: GAME_WIDTH - 40, useCeil: true }
                }
            ).setOrigin(0.5);

            // Gestion des contrôles clavier (sans plein écran)
            this.input.keyboard.on('keydown', () => {
                if (direction.x === 0 && direction.y === 0) {
                    startText.destroy();
                    // Afficher les commandes tactiles après le début du jeu
                    if (window.innerWidth < 768) {
                       touchControls.classList.add('active');
                    }
                }
            });

            // Gestion des contrôles tactiles (sans plein écran)
            let startX, startY;
            this.input.on('pointerdown', (pointer) => {
                if (gameOver) return;
                startX = pointer.x;
                startY = pointer.y;
            });

            this.input.on('pointerup', (pointer) => {
                if (gameOver) return;
                const endX = pointer.x;
                const endY = pointer.y;
                const diffX = endX - startX;
                const diffY = endY - startY;

                if (direction.x === 0 && direction.y === 0) {
                    startText.destroy();
                    // Afficher les commandes tactiles après le début du jeu
                    if (window.innerWidth < 768) {
                       touchControls.classList.add('active');
                    }
                }

                if (Math.abs(diffX) > Math.abs(diffY)) {
                    if (diffX > 0 && lastDirection.x === 0) direction.set(1, 0);
                    else if (diffX < 0 && lastDirection.x === 0) direction.set(-1, 0);
                } else {
                    if (diffY > 0 && lastDirection.y === 0) direction.set(0, 1);
                    else if (diffY < 0 && lastDirection.y === 0) direction.set(0, -1);
                }
                lastDirection.copy(direction);
            });

            document.querySelectorAll('.touch-controls .button').forEach(button => {
                button.addEventListener('click', (e) => {
                    if (gameOver) return;
                    if (direction.x === 0 && direction.y === 0) {
                        startText.destroy();
                    }
                    const dir = e.target.getAttribute('data-direction');
                    if (dir === 'up' && lastDirection.y === 0) direction.set(0, -1);
                    else if (dir === 'down' && lastDirection.y === 0) direction.set(0, 1);
                    else if (dir === 'left' && lastDirection.x === 0) direction.set(-1, 0);
                    else if (dir === 'right' && lastDirection.x === 0) direction.set(1, 0);
                    lastDirection.copy(direction);
                });
            });

            if (window.innerWidth >= 768) {
                touchControls.classList.remove('active');
            } else {
                touchControls.classList.add('active');
            }
        }

        function update(time, delta) {
            if (gameOver) return;

            if (cursors.left.isDown && lastDirection.x === 0) {
                direction.set(-1, 0);
                lastDirection.copy(direction);
            } else if (cursors.right.isDown && lastDirection.x === 0) {
                direction.set(1, 0);
                lastDirection.copy(direction);
            } else if (cursors.up.isDown && lastDirection.y === 0) {
                direction.set(0, -1);
                lastDirection.copy(direction);
            } else if (cursors.down.isDown && lastDirection.y === 0) {
                direction.set(0, 1);
                lastDirection.copy(direction);
            }

            timeSinceLastMove += delta;
            if (timeSinceLastMove >= MOVE_INTERVAL) {
                timeSinceLastMove = 0;
                moveSnake(this);
            }
        }

        function placeFood(scene) {
            let foodX, foodY;
            let validPosition = false;
            const GAME_WIDTH_IN_BLOCKS = GAME_WIDTH / GRID_SIZE;
            const GAME_HEIGHT_IN_BLOCKS = GAME_HEIGHT / GRID_SIZE;

            while (!validPosition) {
                foodX = Phaser.Math.Between(0, GAME_WIDTH_IN_BLOCKS - 1);
                foodY = Phaser.Math.Between(0, GAME_HEIGHT_IN_BLOCKS - 1);
                validPosition = true;
                for (let i = 0; i < snake.length; i++) {
                    if (snake[i].x === foodX * GRID_SIZE && snake[i].y === foodY * GRID_SIZE) {
                        validPosition = false;
                        break;
                    }
                }
            }

            food.x = foodX * GRID_SIZE;
            food.y = foodY * GRID_SIZE;
            food.clear();
            food.fillStyle(0xe74c3c, 1);
            food.fillCircle(GRID_SIZE / 2, GRID_SIZE / 2, GRID_SIZE / 2);
            food.fillStyle(0x2ecc71, 1);
            food.fillRect(GRID_SIZE / 2 - GRID_SIZE / 8, GRID_SIZE / 2 - GRID_SIZE, GRID_SIZE / 4, GRID_SIZE / 2);
        }

        function moveSnake(scene) {
            if (direction.x === 0 && direction.y === 0) return;
            const newHeadX = snake[0].x + direction.x * GRID_SIZE;
            const newHeadY = snake[0].y + direction.y * GRID_SIZE;

            if (newHeadX < 0 || newHeadX >= GAME_WIDTH || newHeadY < 0 || newHeadY >= GAME_HEIGHT) {
                endGame(scene);
                return;
            }

            for (let i = 0; i < snake.length; i++) {
                if (newHeadX === snake[i].x && newHeadY === snake[i].y) {
                    endGame(scene);
                    return;
                }
            }

            const newHeadSegment = scene.add.circle(
                newHeadX,
                newHeadY,
                GRID_SIZE / 2,
                0x76c46a
            ).setOrigin(0);
            const eyeSize = GRID_SIZE / 8;
            const eye1 = scene.add.circle(-eyeSize, -eyeSize, eyeSize, 0x000000);
            const eye2 = scene.add.circle(eyeSize, -eyeSize, eyeSize, 0x000000);
            newHeadSegment.eyes = scene.add.container(newHeadSegment.x + GRID_SIZE / 2, newHeadSegment.y + GRID_SIZE / 2, [eye1, eye2]);
            
            if (direction.x === 1) newHeadSegment.eyes.setRotation(0);
            else if (direction.x === -1) newHeadSegment.eyes.setRotation(Math.PI);
            else if (direction.y === -1) newHeadSegment.eyes.setRotation(-Math.PI / 2);
            else if (direction.y === 1) newHeadSegment.eyes.setRotation(Math.PI / 2);
            
            snake[0].setFillStyle(0x6aa84f);
            if (snake[0].eyes) snake[0].eyes.visible = false;
            snake.unshift(newHeadSegment);

            const headCenter = { x: newHeadSegment.x + GRID_SIZE / 2, y: newHeadSegment.y + GRID_SIZE / 2 };
            const foodCenter = { x: food.x + GRID_SIZE / 2, y: food.y + GRID_SIZE / 2 };
            if (Phaser.Math.Distance.Between(headCenter.x, headCenter.y, foodCenter.x, foodCenter.y) < GRID_SIZE) {
                score++;
                scoreDisplay.textContent = 'Score: ' + score;
                scene.tweens.add({
                    targets: food,
                    scale: 0,
                    alpha: 0,
                    duration: 200,
                    ease: 'Quad.easeOut',
                    onComplete: () => {
                        food.scale = 1;
                        food.alpha = 1;
                        placeFood(scene);
                    }
                });
            } else {
                const tail = snake.pop();
                tail.destroy();
            }
        }

        function endGame(scene) {
            gameOver = true;
            direction.set(0, 0);
            lastDirection.set(0, 0);
            if (touchControls) {
                touchControls.classList.remove('active');
            }
            if (fullscreenButton) {
                fullscreenButton.style.display = 'none';
            }
            
            const restartText = scene.add.text(
                GAME_WIDTH / 2,
                GAME_HEIGHT / 2,
                'Partie terminée !\nScore : ' + score + '\n\nCliquez ou balayez pour rejouer',
                {
                    fontSize: '24px',
                    fill: '#ecf0f1',
                    align: 'center',
                    wordWrap: { width: GAME_WIDTH - 60, useCeil: true }
                }
            ).setOrigin(0.5);

            restartText.setInteractive();
            restartText.on('pointerdown', () => {
                scene.scene.restart();
            });
        }
        
        // Écouteur d'événement pour le bouton de plein écran
        fullscreenButton.addEventListener('click', () => {
            if (document.fullscreenEnabled) {
                gameWrapper.requestFullscreen();
            }
        });
    </script>
</body>
</html>
