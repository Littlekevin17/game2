<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Memory F1 — 5 paires</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      background: #243;
      color: #fff;
      font-family: sans-serif;
      user-select: none;
      overflow: hidden;
    }
    #header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 12px;
      background: #111c;
      color: #fff;
      font-size: 16px;
      height: 40px;
      max-width: 1100px;
      margin: 10px auto 0;
      border-radius: 5px;
      box-sizing: border-box;
    }
    #header > div {
      min-width: 75px;
      text-align: center;
      flex-shrink: 0;
    }
    .header-center {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }
    #restartBtn, #fullscreenBtn {
      cursor: pointer;
      padding: 6px 14px;
      border-radius: 5px;
      border: none;
      background: #0a74da;
      color: white;
      font-weight: bold;
      font-size: 18px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.7);
      user-select: none;
      transition: background 0.2s;
    }
    #fullscreenBtn {
      font-size: 20px;
      padding: 6px 10px;
      margin-left: 3px;
      background: #0a5ba8;
      min-width: 36px;
      width: 36px;
      height: 40px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #restartBtn:hover, #fullscreenBtn:hover {
      background: #09518c;
    }
    #game-parent {
      position: absolute;
      left: 0; right: 0; bottom: 0;
      top: 60px; /* sous le header */
      width: 100vw;
      height: calc(100vh - 60px);
      max-width: 1100px;
      margin: 0 auto;
      background: #222;
    }
    canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
      image-rendering: pixelated;
      -webkit-font-smoothing: none;
      user-select: none;
    }
    @media (max-width: 700px) {
      #header {
        font-size: 13px;
        height: 36px;
        padding: 3px 5px;
      }
      #restartBtn, #fullscreenBtn {
        font-size: 15px;
        padding: 4px 7px;
        height: 32px;
      }
      .header-center {
        gap: 6px;
      }
    }
  </style>
</head>
<body>

  <div id="header">
    <div id="infoMoves">Coups : 0</div>
    <div class="header-center">
      <button id="restartBtn">Rejouer</button>
      <button id="fullscreenBtn" title="Plein écran">🔲</button>
    </div>
    <div id="infoTimer">Temps : 0s</div>
  </div>

  <div id="game-parent"></div>

  <script>
    const PAIRS = 5;
    const COLS = 5;
    const ROWS = 2;
    const CARD_RATIO = 3 / 2;
    const CARD_GAP = 0.03;

    let game;
    let timerId = null;

    function getSizes() {
      const container = document.getElementById('game-parent');
      const w = container.clientWidth;
      const h = container.clientHeight;
      const totalGapWidth = (COLS - 1) * CARD_GAP * w;
      const totalGapHeight = (ROWS - 1) * CARD_GAP * h;
      let cardW = (w - totalGapWidth) / COLS;
      let cardH = cardW / CARD_RATIO;
      if (ROWS * cardH + totalGapHeight > h) {
        cardH = (h - totalGapHeight) / ROWS;
        cardW = cardH * CARD_RATIO;
      }
      const gapW = CARD_GAP * cardW;
      const gapH = CARD_GAP * cardH;
      const boardW = COLS * cardW + (COLS - 1) * gapW;
      const boardH = ROWS * cardH + (ROWS -1) * gapH;
      const startX = (w - boardW) / 2 + cardW / 2;
      const startY = (h - boardH) / 2 + cardH / 2;
      return { w, h, cardW, cardH, gapW, gapH, startX, startY };
    }

    function createConfig() {
      return {
        type: Phaser.AUTO,
        parent: 'game-parent',
        width: document.getElementById('game-parent').clientWidth,
        height: document.getElementById('game-parent').clientHeight,
        backgroundColor: '#243',
        scene: { preload, create },
        scale: { mode: Phaser.Scale.NONE, autoCenter: Phaser.Scale.CENTER_BOTH },
      };
    }

    function preload() {
      this.load.image('back', 'assets/carte-dos.jpg');
      for (let i = 1; i <= PAIRS; i++) {
        this.load.image('face' + i, `assets/${i}.jpg`);
      }
      this.load.audio('matchSound', 'sounds/match.mp3');
      this.load.audio('failSound', 'sounds/fail.mp3');
      this.load.audio('winSound', 'sounds/win.mp3');
    }

    function create() {
      const scene = this;
      const { cardW, cardH, gapW, gapH, startX, startY, w, h } = getSizes();

      let moves = 0;
      let matchedPairs = 0;
      let timer = 0;
      let opened = [];
      let canClick = true;

      const infoMoves = document.getElementById('infoMoves');
      const infoTimer = document.getElementById('infoTimer');
      infoMoves.textContent = 'Coups : 0';
      infoTimer.textContent = 'Temps : 0s';

      if(timerId !== null) {
        clearInterval(timerId);
        timerId = null;
      }

      timerId = setInterval(() => {
        timer++;
        infoTimer.textContent = `Temps : ${timer}s`;
      }, 1000);

      const matchSound = scene.sound.add('matchSound');
      const failSound = scene.sound.add('failSound');
      const winSound = scene.sound.add('winSound');

      const overlay = scene.add.rectangle(w/2, h/2, w, h, 0x000000, 0.5).setDepth(20).setVisible(false);
      const victoryText = scene.add.text(w/2, h/2, '', {
        font: '40px Arial',
        fill: '#0f0',
        backgroundColor: 'rgba(0,0,0,0.8)',
        padding: { left: 24, right: 24, top: 16, bottom: 16 },
        align: 'center',
        wordWrap: { width: w * 0.8 }
      }).setOrigin(0.5).setDepth(21).setVisible(false);

      scene.input.once('pointerdown', () => {
        if (scene.sound.context.state === 'suspended') {
          scene.sound.context.resume();
        }
      });

      // Génération du deck avec 5 paires tirées aléatoirement parmi 20 images
      function getRandomNumbers(min, max, count) {
        const pool = [];
        for(let i = min; i <= max; i++) pool.push(i);
        Phaser.Utils.Array.Shuffle(pool);
        return pool.slice(0, count);
      }

      const cardNumbers = getRandomNumbers(1, 20, PAIRS);

      // Préparation de la liste de cartes (2 par paire)
      let cardValues = [];
      for (const num of cardNumbers) {
        cardValues.push(num, num);
      }
      Phaser.Utils.Array.Shuffle(cardValues);

      // Création sprites
      for (let idx = 0; idx < cardValues.length; idx++) {
        const val = cardValues[idx];
        const xIdx = idx % COLS;
        const yIdx = Math.floor(idx / COLS);
        const posX = startX + xIdx * (cardW + gapW);
        const posY = startY + yIdx * (cardH + gapH);

        let container = scene.add.container(posX, posY);
        let cardBack = scene.add.image(0, 0, 'back').setDisplaySize(cardW, cardH);
        let cardFace = scene.add.image(0, 0, `face${val}`).setDisplaySize(cardW, cardH).setVisible(false);

        container.add([cardBack, cardFace]);
        container.setSize(cardW, cardH);
        container.setInteractive();

        container.cardValue = val;
        container.flipped = false;
        container.locked = false;
        container.cardBack = cardBack;
        container.cardFace = cardFace;

        container.on('pointerdown', () => {
          if (!canClick || container.flipped || container.locked) {
            return;
          }
          canClick = false;

          scene.tweens.add({
            targets: container,
            scaleX: 0,
            duration: 120,
            onComplete: () => {
              container.cardBack.setVisible(false);
              container.cardFace.setVisible(true);

              scene.tweens.add({
                targets: container,
                scaleX: 1,
                duration: 110,
                onComplete: () => {
                  container.flipped = true;
                  opened.push(container);

                  if (opened.length === 2) {
                    moves++;
                    infoMoves.textContent = `Coups : ${moves}`;

                    const [first, second] = opened;

                    if (first.cardValue === second.cardValue) {
                      matchSound.play();
                      first.locked = true;
                      second.locked = true;
                      matchedPairs++;

                      scene.tweens.add({
                        targets: [first, second],
                        scale: 1.12,
                        yoyo: true,
                        duration: 250,
                      });

                      if (matchedPairs === PAIRS) {
                        clearInterval(timerId);
                        timerId = null;
                        winSound.play();
                        overlay.setVisible(true);
                        victoryText.setText(`Félicitations !\n${moves} coups\n${timer}s`);
                        victoryText.setVisible(true);
                        scene.tweens.add({
                          targets: victoryText,
                          scale: 1.2,
                          yoyo: true,
                          repeat: 4,
                          duration: 300,
                        });
                        canClick = false;
                      }

                      opened = [];
                      setTimeout(() => {
                        canClick = true;
                      }, 200);

                    } else {
                      failSound.play();

                      setTimeout(() => {
                        scene.tweens.add({
                          targets: [first, second],
                          scaleX: 0,
                          duration: 150,
                          onComplete: () => {
                            [first, second].forEach(card => {
                              card.cardBack.setVisible(true);
                              card.cardFace.setVisible(false);
                              card.flipped = false;
                            });
                            scene.tweens.add({
                              targets: [first, second],
                              scaleX: 1,
                              duration: 150,
                              onComplete: () => {
                                opened = [];
                                canClick = true;
                              },
                            });
                          },
                        });
                      }, 700);
                    }
                  } else {
                    canClick = true;
                  }
                },
              });
            },
          });
        });
      }

      document.getElementById('restartBtn').onclick = () => {
        if(timerId !== null){
          clearInterval(timerId);
          timerId = null;
        }
        game.destroy(true);
        document.getElementById('game-parent').innerHTML = '';
        setTimeout(() => {
          game = new Phaser.Game(createConfig());
        }, 20);
      };
    }

    // Gestion du bouton plein écran (toggle)
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    fullscreenBtn.onclick = () => {
      if (
        !document.fullscreenElement &&
        !document.webkitFullscreenElement &&
        !document.mozFullScreenElement &&
        !document.msFullscreenElement
      ) {
        const elem = document.documentElement;
        if (elem.requestFullscreen) elem.requestFullscreen();
        else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
        else if (elem.mozRequestFullScreen) elem.mozRequestFullScreen();
        else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
      } else {
        if (document.exitFullscreen) document.exitFullscreen();
        else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
        else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
        else if (document.msExitFullscreen) document.msExitFullscreen();
      }
    };

    // Changement d’icône et tooltip selon état fullscreen
    document.addEventListener('fullscreenchange', () => {
      if (document.fullscreenElement) {
        fullscreenBtn.title = 'Quitter le plein écran';
        fullscreenBtn.textContent = '❎';
      } else {
        fullscreenBtn.title = 'Plein écran';
        fullscreenBtn.textContent = '🔲';
      }
    });

    // Gestion resize – recrée le jeu proprement
    window.addEventListener('resize', () => {
      if (game) {
        if(timerId !== null){
          clearInterval(timerId);
          timerId = null;
        }
        game.destroy(true);
        document.getElementById('game-parent').innerHTML = '';
        setTimeout(() => {
          game = new Phaser.Game(createConfig());
        }, 50);
      }
    });

    // Lancement initial
    window.onload = () => {
      game = new Phaser.Game(createConfig());
    };
  </script>

</body>
</html>
