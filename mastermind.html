<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mastermind Mobile - Phaser 3</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: #e3f2fd;
            height: 100%;
            overflow: hidden;
        }
        #phaser-game {
            width: 100vw;
            height: 100vh;
            display: block;
            touch-action: manipulation;
        }
        body {
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="phaser-game"></div>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
    <script>
const NB_TENTATIVES = 12; // tu peux changer ici si tu veux plus/moins !
const NB_PIONS = 4;

const config = {
    type: Phaser.AUTO,
    backgroundColor: '#f0f0f0',
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        parent: 'phaser-game',
        width: 380,
        height: 700,
        min: { width: 320, height: 480 },
        max: { width: 900, height: 1200 }
    },
    scene: { preload, create, update }
};

const game = new Phaser.Game(config);

function preload() {}

function create() {
    this.colors = [0xe57373, 0x64b5f6, 0xffb74d, 0x81c784, 0xba68c8, 0xffeb3b];
    this.secret = Phaser.Utils.Array.Shuffle(this.colors.slice()).slice(0, NB_PIONS);

    this.currentTry = [];
    this.currentRow = 0;
    this.disableInput = false;
    this.feedbacks = []; // feedbacks persistants
    this.grid = [];
    this.feedbackGrid = [];

    // Responsive portrait/paysage
    this.isPortrait = this.sys.game.config.height > this.sys.game.config.width;

    // Positions (calcul auto sur orientation)
    this.getGridPosition = (row, col) => {
        let margin = 20,
            gridWidth = NB_PIONS * 55,
            startX = this.isPortrait ? (this.sys.game.config.width - gridWidth) / 2 : margin + 30,
            startY = 80;
        return {
            x: startX + col * 55,
            y: startY + row * 46
        };
    };
    this.getFeedbackPosition = (row) => {
        let fx = this.isPortrait ? this.sys.game.config.width - 72 : this.sys.game.config.width - 116;
        let fy = 80 + row * 46;
        return { x: fx, y: fy };
    };

    // Grille de jeu
    for (let row = 0; row < NB_TENTATIVES; row++) {
        let guessRow = [];
        for (let col = 0; col < NB_PIONS; col++) {
            let pos = this.getGridPosition(row, col);
            let circle = this.add.circle(pos.x, pos.y, 19, 0xdddddd)
                .setStrokeStyle(2, 0x888888)
                .setAlpha(1)
                .setDepth(1);
            guessRow.push(circle);
        }
        this.grid.push(guessRow);
        // Pré-alloue un groupe d'objets feedback pour ce row
        let feedbacks = [];
        let posF = this.getFeedbackPosition(row);
        for (let i = 0; i < NB_PIONS; i++) {
            // Placer en colonne serrée (2x2), façon Mastermind classique :
            let modx = (i % 2) * 15, mody = Math.floor(i / 2) * 15;
            let feedback = this.add.circle(posF.x + modx, posF.y + mody, 7, 0xf0f0f0)
                            .setStrokeStyle(1, 0xbbbbbb)
                            .setVisible(false);
            feedbacks.push(feedback);
        }
        this.feedbackGrid.push(feedbacks);
    }

    // Palette de choix couleur (bas en portrait, droite en paysage)
    let baseX = this.isPortrait ? (this.sys.game.config.width - this.colors.length * 48) / 2 : this.sys.game.config.width - 60;
    let baseY = this.isPortrait ? this.sys.game.config.height - 120 : 54;
    this.choix = [];
    for (let c = 0; c < this.colors.length; c++) {
        let x = this.isPortrait ? baseX + c * 48 : baseX;
        let y = this.isPortrait ? baseY : baseY + c * 48;
        let circ = this.add.circle(x, y, 21, this.colors[c])
            .setInteractive({ useHandCursor: true })
            .setStrokeStyle(3, 0xfafafa);
        circ.colorValue = this.colors[c];
        this.choix.push(circ);
    }

    // Instructions et tentative
    this.instructionText = this.add.text(
        this.sys.game.config.width/2, 20,
        'Sélectionnez 4 couleurs',
        { fontSize: '18px', fill: '#222', fontFamily: 'Arial', align: 'center' }
    ).setOrigin(0.5);

    this.tentativeText = this.add.text(
        this.sys.game.config.width - 20, 50, 
        `Tentative 1/${NB_TENTATIVES}`,
        { fontSize: '15px', fill: '#607d8b', fontFamily: 'Arial', align: 'right' }
    ).setOrigin(1, 0.5);

    // Palette click interaction + animation pop
    this.choix.forEach(circ => {
        circ.on('pointerdown', () => {
            if (this.currentTry.length < NB_PIONS && !this.disableInput) {
                this.tweens.add({
                    targets: circ,
                    scale: 1.25,
                    duration: 100,
                    yoyo: true
                });
                let circleToFill = this.grid[this.currentRow][this.currentTry.length];
                circleToFill.setFillStyle(circ.colorValue);
                this.tweens.add({
                    targets: circleToFill,
                    scale: 1.2,
                    duration: 120,
                    yoyo: true
                });
                this.currentTry.push(circ.colorValue);
                if (this.currentTry.length === NB_PIONS) this.checkTry();
            }
        });
    });

    // Bouton Nouvelle partie TOUT en bas, centré
    this.resetButton = this.add.text(
            this.sys.game.config.width / 2, this.sys.game.config.height - 32,
            'Nouvelle partie',
            { fontSize: '20px', fill: '#1976d2', fontFamily: 'Arial', backgroundColor: '#bbdefb', padding: 10, align: 'center' }
        )
        .setInteractive({ useHandCursor: true })
        .setOrigin(0.5)
        .setAlpha(0.95)
        .setDepth(10)
        .on('pointerdown', () => this.resetGame());

    this.statusText = this.add.text(
        18, this.sys.game.config.height - 68,
        '',
        { fontSize: '16px', fill: '#388e3c', fontFamily: 'Arial' }
    );

    // logiques portées pour le scope
    this.checkTry = function() {
        let wellPlaced = 0, misplaced = 0;
        let tempSecret = [...this.secret];
        let tempTry = [...this.currentTry];
        // Bien placés
        for (let i = 0; i < NB_PIONS; i++) {
            if (tempTry[i] === tempSecret[i]) {
                wellPlaced++;
                tempSecret[i] = tempTry[i] = null;
            }
        }
        // Mal placés
        for (let i = 0; i < NB_PIONS; i++) {
            if (tempTry[i] !== null && tempSecret.includes(tempTry[i])) {
                misplaced++;
                tempSecret[tempSecret.indexOf(tempTry[i])] = null;
            }
        }
        this.showFeedback(this.currentRow, wellPlaced, misplaced);

        if (wellPlaced === NB_PIONS) {
            this.instructionText.setText('Bravo ! Code trouvé !');
            this.statusText.setText('Clique sur Nouvelle partie pour rejouer.');
            this.disableInput = true;
        } else if (this.currentRow >= NB_TENTATIVES - 1) {
            this.instructionText.setText('Perdu ! Code :');
            this.showSecret();
            this.statusText.setText('Clique sur Nouvelle partie pour rejouer.');
            this.disableInput = true;
        } else {
            this.currentRow++;
            this.currentTry = [];
            this.tentativeText.setText(`Tentative ${this.currentRow+1}/${NB_TENTATIVES}`);
        }
    };

    this.showFeedback = function(row, wellPlaced, misplaced) {
        let feedbacks = this.feedbackGrid[row];
        let total = 0;
        // D'abord noirs (bien placés)
        for (let i = 0; i < wellPlaced && total < NB_PIONS; i++, total++) {
            feedbacks[total].setFillStyle(0x222222).setVisible(true);
            this.tweens.add({ targets: feedbacks[total], scale: { from: 0.3, to: 1 }, duration: 240 });
        }
        // Puis blancs (mal placés)
        for (let i = 0; i < misplaced && total < NB_PIONS; i++, total++) {
            feedbacks[total].setFillStyle(0xffffff).setVisible(true);
            this.tweens.add({ targets: feedbacks[total], scale: { from: 0.3, to: 1 }, duration: 220 });
        }
        // Les autres restent invisibles ou restés en gris clair
    };

    this.showSecret = function() {
        for (let i = 0; i < this.secret.length; i++) {
            let pos = this.getGridPosition(this.currentRow, i);
            let circ = this.add.circle(pos.x, pos.y, 19, this.secret[i]).setStrokeStyle(4, 0x1976d2);
            circ.setDepth(9);
            this.tweens.add({
                targets: circ,
                alpha: { from: 0, to: 1 }, duration: 500
            });
        }
    };

    this.resetGame = function() {
        this.secret = Phaser.Utils.Array.Shuffle(this.colors.slice()).slice(0, NB_PIONS);
        this.currentTry = [];
        this.currentRow = 0;
        this.disableInput = false;
        // Vider la grille
        this.grid.forEach(row => row.forEach(circle => circle.setFillStyle(0xdddddd)));
        // Efface tous les feedbacks
        for (let row = 0; row < NB_TENTATIVES; row++)
            for (let f = 0; f < NB_PIONS; f++)
                this.feedbackGrid[row][f].setVisible(false).setFillStyle(0xf0f0f0);
        this.statusText.setText('');
        this.instructionText.setText('Sélectionnez 4 couleurs');
        this.tentativeText.setText(`Tentative 1/${NB_TENTATIVES}`);
    };
}

function update() {}
    </script>
</body>
</html>
