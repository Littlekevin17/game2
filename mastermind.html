<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mastermind Mobile - Phaser 3 corrigé</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: radial-gradient(circle at 50% 30%, #e3f2fd 80%, #cfd8dc 100%);
      height: 100vh;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    #phaser-game {
      width: 100vw;
      height: 100vh;
      display: block;
      touch-action: manipulation;
    }
    #fs-icon {
        position: fixed;
        right: 14px; bottom: 20px;
        width: 44px; height: 44px;
        background: rgba(240,240,240,0.85);
        border-radius: 11px;
        box-shadow: 2px 2px 10px #ccc;
        display: flex; justify-content: center; align-items: center;
        z-index: 998;
        border: 1.5px solid #90caf9;
        cursor: pointer;
        user-select: none;
        -webkit-user-select: none;
    }
    #fs-icon:hover {
        background: #ffffff;
    }
    #fs-icon svg {
        width: 26px; height: 26px;
        fill: #1976d2;
    }
    @media (max-width:490px) {
        #fs-icon { width:36px; height:36px; }
        #fs-icon svg { width:20px; height:20px; }
    }
  </style>
</head>
<body>
  <div id="phaser-game"></div>
  <!-- Icone plein écran -->
  <div id="fs-icon" title="Plein écran">
    <svg id="fs-svg" viewBox="0 0 24 24">
      <rect x="4" y="4" width="16" height="16" rx="4.5"></rect>
    </svg>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <script>
    const NB_TENTATIVES = 12;
    const NB_PIONS = 4;

    const config = {
      type: Phaser.AUTO,
      backgroundColor: '#f0f3fa',
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        parent: 'phaser-game',
        width: 380,
        height: 700,
        min: { width: 320, height: 480 },
        max: { width: 900, height: 1200 }
      },
      scene: { preload, create, update }
    };

    const game = new Phaser.Game(config);

    function preload() {}

    function create() {
      this.colors = [0xe57373, 0x64b5f6, 0xffb74d, 0x81c784, 0xba68c8, 0xffeb3b];
      this.secret = Phaser.Utils.Array.Shuffle(this.colors.slice()).slice(0, NB_PIONS);

      this.currentTry = [];
      this.currentRow = 0;
      this.disableInput = false;
      this.grid = [];
      this.feedbackGrid = [];

      this.isPortrait = this.sys.game.config.height > this.sys.game.config.width;

      this.getGridPosition = (row, col) => {
        const gridWidth = NB_PIONS * 54;
        const startX = (this.sys.game.config.width - gridWidth) / 2;
        const startY = 82;
        return { x: startX + col * 54, y: startY + row * 45 };
      };
      this.getFeedbackPosition = (row) => {
        const fx = this.sys.game.config.width - 64;
        const fy = 82 + row * 45;
        return { x: fx, y: fy };
      };

      // Création grille + feedback
      for (let row = 0; row < NB_TENTATIVES; row++) {
        let guessRow = [];
        for (let col = 0; col < NB_PIONS; col++) {
          let pos = this.getGridPosition(row, col);
          let circle = this.add.circle(pos.x, pos.y, 19, 0xffffff)
            .setStrokeStyle(2.5, 0xaaaebc)
            .setAlpha(0.97)
            .setDepth(1);
          guessRow.push(circle);
        }
        this.grid.push(guessRow);

        // Feedback
        let feedbacks = [];
        let posF = this.getFeedbackPosition(row);
        for (let i = 0; i < NB_PIONS; i++) {
          let dx = (i % 2) * 15, dy = Math.floor(i / 2) * 15;
          let feedback = this.add.circle(posF.x + dx, posF.y + dy, 7.5, 0xf4f6fd)
            .setStrokeStyle(1, 0xbbbbbb)
            .setVisible(false);
          feedbacks.push(feedback);
        }
        this.feedbackGrid.push(feedbacks);
      }

      // Palette couleurs en bas sous la grille
      const paletteY = this.getGridPosition(NB_TENTATIVES - 1, 0).y + 47;
      const paletteX = (this.sys.game.config.width - this.colors.length * 47) / 2;
      this.choix = [];
      for (let c = 0; c < this.colors.length; c++) {
        let x = paletteX + c * 47;
        let y = paletteY;
        let circ = this.add.circle(x, y, 22, this.colors[c])
          .setInteractive({ useHandCursor: true })
          .setStrokeStyle(3.6, 0xffffff)
          .setAlpha(1);
        circ.colorValue = this.colors[c];
        circ.colorIndex = c;
        this.choix.push(circ);
      }

      // Texte en-tête et tentative
      this.instructionText = this.add.text(
        this.sys.game.config.width / 2, 22,
        'Sélectionnez 4 couleurs',
        { fontSize: '18px', fill: '#1a237e', fontFamily: 'Arial', align: 'center', fontStyle: 'bold', shadow: { color: '#789', fill: true, blur: 2, offsetX: 1, offsetY: 1 } }
      ).setOrigin(0.5);

      this.tentativeText = this.add.text(
        this.sys.game.config.width - 24, 54,
        `Essai 1/${NB_TENTATIVES}`,
        { fontSize: '15px', fill: '#1976d2', fontFamily: 'Arial', align: 'right', fontStyle: 'bold' }
      ).setOrigin(1, 0.5);

      // Interaction clic palette - interdiction doublons dans proposition courante
      this.currentTry = [];
      this.choix.forEach(circ => {
        circ.on('pointerdown', () => {
          if (this.disableInput) return;
          if (this.currentTry.length < NB_PIONS && !this.currentTry.includes(circ.colorValue)) {
            this.tweens.add({ targets: circ, scale: 1.15, duration: 80, yoyo: true });
            const idx = this.currentTry.length;
            const cell = this.grid[this.currentRow][idx];
            cell.setFillStyle(circ.colorValue).setData('filled', circ.colorValue);
            this.currentTry.push(circ.colorValue);
            circ.setAlpha(0.43);

            cell.removeAllListeners('pointerdown');
            cell.setInteractive({ useHandCursor: true });
            cell.on('pointerdown', () => { this.removePion(this.currentRow, idx); });

            if (this.currentTry.length === NB_PIONS) this.checkTry();
          }
        });
      });

      // Retrait pastille posée sur ligne courante
      this.removePion = (row, colIdx) => {
        if (this.currentRow !== row || this.disableInput) return;
        const removedColor = this.grid[row][colIdx].getData('filled');
        if (!removedColor) return;
        this.currentTry.splice(colIdx, 1);
        this.grid[row][colIdx].setFillStyle(0xffffff).setData('filled', null);
        // Décale vers la gauche
        for (let c = colIdx + 1; c < NB_PIONS; c++) {
          let val = this.grid[row][c].getData('filled');
          this.grid[row][c - 1].setFillStyle(val ? val : 0xffffff);
          this.grid[row][c - 1].setData('filled', val || null);
          this.grid[row][c].setFillStyle(0xffffff).setData('filled', null);
        }
        // Réactive la couleur dans palette
        this.choix.forEach(cc => {
          if (cc.colorValue === removedColor) cc.setAlpha(1);
        });
        // Réassocie listener pointerdown sur pastilles restantes
        for (let k = 0; k < NB_PIONS; k++) {
          this.grid[row][k].removeAllListeners('pointerdown');
          if (this.grid[row][k].getData('filled')) {
            this.grid[row][k].setInteractive({ useHandCursor: true });
            this.grid[row][k].on('pointerdown', () => this.removePion(row, k));
          }
        }
      };

      // Bouton Nouvelle partie sous palette
      this.resetButton = this.add.text(
        this.sys.game.config.width / 2, paletteY + 54,
        'Nouvelle partie',
        { fontSize: '20px', fill: '#1976d2', fontFamily: 'Arial', backgroundColor: '#bbdefb', padding: 10, align: 'center', borderRadius: 9 }
      )
        .setInteractive({ useHandCursor: true })
        .setOrigin(0.5)
        .setAlpha(0.98)
        .setDepth(10)
        .on('pointerdown', () => this.resetGame());

      // Texte de statut discret en bas à gauche
      this.statusText = this.add.text(
        18, this.sys.game.config.height - 82,
        '', { fontSize: '15px', fill: '#388e3c', fontFamily: 'Arial' }
      );

      // Fonction pour montrer les pastilles feedback (noires & blanches)
      this.showFeedback = (row, wellPlaced, misplaced) => {
        let feedbacks = this.feedbackGrid[row];
        let total = 0;
        for (let i = 0; i < wellPlaced && total < NB_PIONS; i++, total++) {
          feedbacks[total].setFillStyle(0x222222).setVisible(true);
          this.tweens.add({ targets: feedbacks[total], scale: { from: 0.35, to: 1 }, duration: 180 });
        }
        for (let i = 0; i < misplaced && total < NB_PIONS; i++, total++) {
          feedbacks[total].setFillStyle(0xffffff).setVisible(true);
          this.tweens.add({ targets: feedbacks[total], scale: { from: 0.35, to: 1 }, duration: 150 });
        }
      };

      // Affiche le code secret en fin de partie
      this.showSecret = () => {
        for (let i = 0; i < this.secret.length; i++) {
          let pos = this.getGridPosition(this.currentRow, i);
          let circ = this.add.circle(pos.x, pos.y, 19, this.secret[i])
            .setStrokeStyle(4, 0x1976d2)
            .setDepth(9)
            .setAlpha(0);
          this.tweens.add({ targets: circ, alpha: { from: 0, to: 1 }, duration: 500 });
        }
      };

      // Vérifie la tentative quand 4 pions sont posés
      this.checkTry = () => {
        let wellPlaced = 0, misplaced = 0;
        let tempSecret = [...this.secret];
        let tempTry = [...this.currentTry];

        for (let i = 0; i < NB_PIONS; i++) {
          if (tempTry[i] === tempSecret[i]) {
            wellPlaced++;
            tempSecret[i] = tempTry[i] = null;
          }
        }
        for (let i = 0; i < NB_PIONS; i++) {
          if (tempTry[i] !== null && tempSecret.includes(tempTry[i])) {
            misplaced++;
            tempSecret[tempSecret.indexOf(tempTry[i])] = null;
          }
        }
        this.showFeedback(this.currentRow, wellPlaced, misplaced);

        if (wellPlaced === NB_PIONS) {
          this.instructionText.setText('Bravo\u00A0! Code trouvé !');
          this.statusText.setText('Clique sur Nouvelle partie pour rejouer.');
          this.disableInput = true;
        } else if (this.currentRow >= NB_TENTATIVES - 1) {
          this.instructionText.setText('Perdu ! Code :');
          this.showSecret();
          this.statusText.setText('Clique sur Nouvelle partie pour rejouer.');
          this.disableInput = true;
        } else {
          this.currentRow++;
          this.currentTry = [];
          this.tentativeText.setText(`Essai ${this.currentRow + 1}/${NB_TENTATIVES}`);
          this.choix.forEach(cc => cc.setAlpha(1));
          // Réinitialiser nouvelle ligne et listeners
          this.grid[this.currentRow].forEach((cell, idx) => {
            cell.removeAllListeners('pointerdown');
            cell.setFillStyle(0xffffff);
            cell.setData('filled', null);
            cell.setInteractive({ useHandCursor: true });
            cell.on('pointerdown', () => {
              if (!this.disableInput) this.removePion(this.currentRow, idx);
            });
          });
        }
      };

      // Reset complet du jeu
      this.resetGame = () => {
        this.secret = Phaser.Utils.Array.Shuffle(this.colors.slice()).slice(0, NB_PIONS);
        this.currentTry = [];
        this.currentRow = 0;
        this.disableInput = false;
        if (this.grid && Array.isArray(this.grid)) {
          this.grid.forEach(row => {
            if (Array.isArray(row)) {
              row.forEach(cell => {
                if (cell && cell.setFillStyle) {
                  cell.setFillStyle(0xffffff);
                  cell.setData('filled', null);
                  cell.removeAllListeners('pointerdown');
                  cell.setInteractive({ useHandCursor: true });
                }
              });
            }
          });
        }
        if (this.feedbackGrid && Array.isArray(this.feedbackGrid)) {
          this.feedbackGrid.forEach(row => {
            if (Array.isArray(row)) {
              row.forEach(feedback => {
                if (feedback && feedback.setVisible) {
                  feedback.setVisible(false);
                  feedback.setFillStyle(0xf4f6fd);
                }
              });
            }
          });
        }
        this.statusText.setText('');
        this.instructionText.setText('Sélectionnez 4 couleurs');
        this.tentativeText.setText(`Essai 1/${NB_TENTATIVES}`);
        this.choix.forEach(cc => cc.setAlpha(1));
        // Setup listeners sur la première ligne (ligne 0)
        if (this.grid[0]) {
          this.grid[0].forEach((cell, idx) => {
            cell.setInteractive({ useHandCursor: true });
            cell.on('pointerdown', () => {
              if (!this.disableInput) this.removePion(0, idx);
            });
          });
        }
      };

      // Initialise le jeu
      this.resetGame();
    }

    function update() {}

    // Gestion du bouton plein écran natif hors du canvas (HTML + JS)
    const fsIcon = document.getElementById('fs-icon');
    const fsSVG = document.getElementById('fs-svg');

    function toggleFullscreen() {
      const s = game.scale;
      if (!s.isFullscreen) {
        s.startFullscreen();
        // Icône sortie fullscreen
        fsSVG.innerHTML = '<svg viewBox="0 0 24 24"><rect x="6" y="6" width="12" height="12" rx="3.5" stroke="#1976d2" stroke-width="2.2" fill="none"/></svg>';
      } else {
        s.stopFullscreen();
        // Icône entrée fullscreen
        fsSVG.innerHTML = '<rect x="4" y="4" width="16" height="16" rx="4.5"></rect>';
      }
    }

    fsIcon.addEventListener('click', e => {
      e.preventDefault();
      toggleFullscreen();
    });

    document.addEventListener('fullscreenchange', () => {
      const s = game.scale;
      if (!s.isFullscreen) {
        fsSVG.innerHTML = '<rect x="4" y="4" width="16" height="16" rx="4.5"></rect>';
      }
    });
  </script>
</body>
</html>
